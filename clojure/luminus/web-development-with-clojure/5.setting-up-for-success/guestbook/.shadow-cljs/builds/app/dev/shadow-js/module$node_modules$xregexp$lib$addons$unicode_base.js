["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/xregexp/lib/addons/unicode-base.js"],"~:js","shadow$provide.module$node_modules$xregexp$lib$addons$unicode_base=function(global,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if(\"undefined\"===typeof _symbol[\"default\"]||null==(0,_getIteratorMethod2[\"default\"])(o)){if((0,_isArray[\"default\"])(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&\"number\"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},\ne:function(_e){throw _e;},f:allowArrayLike}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=(0,_getIterator2[\"default\"])(o)},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it[\"return\"])it[\"return\"]()}finally{if(didErr)throw err;\n}}}}function _unsupportedIterableToArray(o,minLen){var _context4;if(o){if(\"string\"===typeof o)return _arrayLikeToArray(o,minLen);var n=(0,_slice[\"default\"])(_context4=Object.prototype.toString.call(o)).call(_context4,8,-1);\"Object\"===n&&o.constructor&&(n=o.constructor.name);if(\"Map\"===n||\"Set\"===n)return(0,_from[\"default\"])(o);if(\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=\narr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}global=require(\"module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault\");require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property\")(exports,\"__esModule\",{value:!0});exports[\"default\"]=void 0;var _getIterator2=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js$get_iterator\")),_isArray=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$array$is_array\")),\n_getIteratorMethod2=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js$get_iterator_method\")),_symbol=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$symbol\")),_from=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$array$from\")),_slice=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$slice\")),_includes=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes\")),_concat=\nglobal(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat\")),_forEach=global(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$for_each\"));exports[\"default\"]=function(XRegExp){function normalize(name){return name.replace(/[- _]+/g,\"\").toLowerCase()}function charCode(chr){var esc=/^\\\\[xu](.+)/.exec(chr);return esc?dec(esc[1]):chr.charCodeAt(\"\\\\\"===chr[0]?1:0)}function invertBmp(range){var output=\"\",lastEnd=-1;(0,_forEach[\"default\"])(XRegExp).call(XRegExp,\nrange,/(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,function(m){var start=charCode(m[1]);start>lastEnd+1&&(output+=\"\\\\u\".concat(pad4(hex(lastEnd+1))),start>lastEnd+2&&(output+=\"-\\\\u\".concat(pad4(hex(start-1)))));lastEnd=charCode(m[2]||m[1])});65535>lastEnd&&(output+=\"\\\\u\".concat(pad4(hex(lastEnd+1))),65534>lastEnd&&(output+=\"-\\\\uFFFF\"));return output}var unicode={},dec=XRegExp._dec,hex=XRegExp._hex,pad4=XRegExp._pad4;XRegExp.addToken(/\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,function(match,\nscope,flags){var isNegated=\"P\"===match[1]||!!match[2],isAstralMode=(0,_includes[\"default\"])(flags).call(flags,\"A\");flags=normalize(match[4]||match[3]);var item=unicode[flags];if(\"P\"===match[1]&&match[2])throw new SyntaxError(\"Invalid double negation \"+match[0]);if(!unicode.hasOwnProperty(flags))throw new SyntaxError(\"Unknown Unicode token \"+match[0]);if(item.inverseOf){flags=normalize(item.inverseOf);if(!unicode.hasOwnProperty(flags)){var _context3;throw new ReferenceError((0,_concat[\"default\"])(_context3=\n\"\".concat(\"Unicode token missing data \"+match[0],\" -\\x3e \")).call(_context3,item.inverseOf));}item=unicode[flags];isNegated=!isNegated}if(!item.bmp&&!isAstralMode)throw new SyntaxError(\"Astral mode required for Unicode token \"+match[0]);if(isAstralMode){if(\"class\"===scope)throw new SyntaxError(\"Astral mode does not support Unicode tokens within character classes\");match=isNegated?\"a!\":\"a\\x3d\";if(!(scope=unicode[flags][match])){scope=unicode[flags];var JSCompiler_inline_result;flags=unicode[flags];\n_context3=\"\";flags.bmp&&!flags.isBmpLast&&(_context3=(0,_concat[\"default\"])(JSCompiler_inline_result=\"[\".concat(flags.bmp,\"]\")).call(JSCompiler_inline_result,flags.astral?\"|\":\"\"));flags.astral&&(_context3+=flags.astral);if(flags.isBmpLast&&flags.bmp){var _context2;_context3+=(0,_concat[\"default\"])(_context2=\"\".concat(flags.astral?\"|\":\"\",\"[\")).call(_context2,flags.bmp,\"]\")}JSCompiler_inline_result=isNegated?\"(?:(?!\".concat(_context3,\")(?:[\\ud800-\\udbff][\\udc00-\\udfff]|[\\x00-ï¿¿]))\"):\"(?:\".concat(_context3,\n\")\");scope=scope[match]=JSCompiler_inline_result}return scope}return\"class\"===scope?isNegated?unicode[flags][\"b!\"]||(unicode[flags][\"b!\"]=invertBmp(unicode[flags].bmp)):item.bmp:\"\".concat((isNegated?\"[^\":\"[\")+item.bmp,\"]\")},{scope:\"all\",optionalFlags:\"A\",leadChar:\"\\\\\"});XRegExp.addUnicodeData=function(data){data=_createForOfIteratorHelper(data);var _step;try{for(data.s();!(_step=data.n()).done;){var item=_step.value;if(!item.name)throw Error(\"Unicode token requires name\");if(!(item.inverseOf||item.bmp||\nitem.astral))throw Error(\"Unicode token has no character data \"+item.name);unicode[normalize(item.name)]=item;item.alias&&(unicode[normalize(item.alias)]=item)}}catch(err){data.e(err)}finally{data.f()}XRegExp.cache.flush(\"patterns\")};XRegExp._getUnicodeProperty=function(name){name=normalize(name);return unicode[name]}};module.exports=exports.default}","~:source","shadow$provide[\"module$node_modules$xregexp$lib$addons$unicode_base\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _getIteratorMethod2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator-method\"));\n\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/symbol\"));\n\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/from\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _symbol[\"default\"] === \"undefined\" || (0, _getIteratorMethod2[\"default\"])(o) == null) { if ((0, _isArray[\"default\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2[\"default\"])(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { var _context4; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = (0, _slice[\"default\"])(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return (0, _from[\"default\"])(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*!\n * XRegExp Unicode Base 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  var unicode = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    (0, _forEach[\"default\"])(XRegExp).call(XRegExp, range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\".concat(pad4(hex(start - 1)));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    var item = unicode[slug];\n    var combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      var _context;\n\n      combined = (0, _concat[\"default\"])(_context = \"[\".concat(item.bmp, \"]\")).call(_context, item.astral ? '|' : '');\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      var _context2;\n\n      combined += (0, _concat[\"default\"])(_context2 = \"\".concat(item.astral ? '|' : '', \"[\")).call(_context2, item.bmp, \"]\");\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? \"(?:(?!\".concat(combined, \")(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))\") : \"(?:\".concat(combined, \")\");\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    var prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\P{..} or \\p{^..}\n\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    var isAstralMode = (0, _includes[\"default\"])(flags).call(flags, 'A'); // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n\n    var slug = normalize(match[4] || match[3]); // Token data object\n\n    var item = unicode[slug];\n\n    if (match[1] === 'P' && match[2]) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        var _context3;\n\n        throw new ReferenceError((0, _concat[\"default\"])(_context3 = \"\".concat(ERR_UNKNOWN_REF + match[0], \" -> \")).call(_context3, item.inverseOf));\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \"\".concat((isNegated ? '[^' : '[') + item.bmp, \"]\");\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n\n    var _iterator = _createForOfIteratorHelper(data),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (!item.name) {\n          throw new Error(ERR_NO_NAME);\n        }\n\n        if (!(item.inverseOf || item.bmp || item.astral)) {\n          throw new Error(ERR_NO_DATA + item.name);\n        }\n\n        unicode[normalize(item.name)] = item;\n\n        if (item.alias) {\n          unicode[normalize(item.alias)] = item;\n        }\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n      // flags might now produce different results\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime_corejs3$core_js$get_iterator_method","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$for_each","~$module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault","~$shadow.js","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$array$from","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property","~$module$node_modules$$babel$runtime_corejs3$core_js$get_iterator","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$symbol","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$slice","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$array$is_array"]],"~:properties",["^5",["n","leadChar","s","f","e","optionalFlags","value","scope","addUnicodeData","_getUnicodeProperty","done"]],"~:compiled-at",1633159627461,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$xregexp$lib$addons$unicode_base.js\",\n\"lineCount\":12,\n\"mappings\":\"AAAAA,cAAA,CAAe,mDAAf,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA+BhHC,QAASA,2BAA0B,CAACC,CAAD,CAAIC,cAAJ,CAAoB,CAAE,IAAIC,EAAI,IAAkC,WAAlC,GAAI,MAAOC,QAAA,CAAQ,SAAR,CAAX,EAA2F,IAA3F,EAAiD,CAAC,CAAA,CAAGC,mBAAA,CAAoB,SAApB,CAAJ,EAAoCJ,CAApC,CAAjD,CAAiG,CAAE,GAAI,CAAC,CAAA,CAAGK,QAAA,CAAS,SAAT,CAAJ,EAAyBL,CAAzB,CAAJ,GAAoCE,EAApC,CAAyCI,2BAAA,CAA4BN,CAA5B,CAAzC,GAA4EC,cAA5E,EAA8FD,CAA9F,EAAuH,QAAvH,GAAmG,MAAOA,EAAP,CAASO,MAA5G,CAAiI,CAAML,EAAJ,GAAQF,CAAR,CAAYE,EAAZ,CAAgB,KAAIM,EAAI,CAAOC,eAAAA,CAAIA,QAAU,EAAG,EAAI,OAAO,CAAEC,EAAGD,cAAL,CAAQE,EAAGA,QAAU,EAAG,CAAE,MAAIH,EAAJ,EAASR,CAAT,CAAWO,MAAX,CAA0B,CAAEK,KAAM,CAAA,CAAR,CAA1B,CAAiD,CAAEA,KAAM,CAAA,CAAR,CAAeC,MAAOb,CAAA,CAAEQ,CAAA,EAAF,CAAtB,CAAnD,CAAxB;AAA8GM,EAAGA,QAAU,CAACC,EAAD,CAAK,CAAE,KAAMA,GAAN,CAAF,CAAhI,CAA+IC,EAAGP,cAAlJ,CAA7D,CAAsN,KAAM,KAAIQ,SAAJ,CAAc,uIAAd,CAAN,CAAzV,CAA3G,IAAwmBC,iBAAmB,CAAA,CAA3nB,CAAioBC,OAAS,CAAA,CAA1oB,CAAipBC,GAAK,OAAO,CAAEV,EAAGA,QAAU,EAAG,CAAER,EAAA,CAAK,CAAC,CAAA,CAAGmB,aAAA,CAAc,SAAd,CAAJ,EAA8BrB,CAA9B,CAAP,CAAlB,CAA8DW,EAAGA,QAAU,EAAG,CAAE,IAAIW,KAAOpB,EAAA,CAAGqB,IAAH,EAAWL,iBAAA,CAAmBI,IAAnB,CAAwBV,IAAM,OAAOU,KAA7D,CAA9E,CAAoJR,EAAGA,QAAU,CAACU,GAAD,CAAM,CAAEL,MAAA,CAAS,CAAA,CAAMC,IAAA,CAAMI,GAAvB,CAAvK,CAAsMR,EAAGA,QAAU,EAAG,CAAE,GAAI,CAAE,GAAI,CAACE,gBAAL,EAAyC,IAAzC,EAAyBhB,EAAA,CAAG,QAAH,CAAzB,CAA+CA,EAAA,CAAG,QAAH,CAAA,EAAjD,CAAJ,OAA+E,CAAE,GAAIiB,MAAJ,CAAY,KAAMC,IAAN;AAAd,CAAjF,CAAtN,CAA7pB,CAEvDd,QAASA,4BAA2B,CAACN,CAAD,CAAIyB,MAAJ,CAAY,CAAE,IAAIC,SAAW,IAAK1B,CAAL,CAAA,CAAgB,GAAiB,QAAjB,GAAI,MAAOA,EAAX,CAA2B,MAAO2B,kBAAA,CAAkB3B,CAAlB,CAAqByB,MAArB,CAA8B,KAAId,EAAI,CAAC,CAAA,CAAGiB,MAAA,CAAO,SAAP,CAAJ,EAAuBF,SAAvB,CAAmCG,MAAA,CAAOC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BhC,CAA/B,CAAnC,CAAA,CAAsEgC,IAAtE,CAA2EN,SAA3E,CAAsF,CAAtF,CAAyF,EAAzF,CAAwG,SAAV,GAAIf,CAAJ,EAAsBX,CAAtB,CAAwBiC,WAAxB,GAAqCtB,CAArC,CAAyCX,CAAzC,CAA2CiC,WAA3C,CAAuDC,IAAvD,CAA6D,IAAU,KAAV,GAAIvB,CAAJ,EAAyB,KAAzB,GAAmBA,CAAnB,CAAgC,MAAO,CAAC,CAAA,CAAGwB,KAAA,CAAM,SAAN,CAAJ,EAAsBnC,CAAtB,CAA0B,IAAU,WAAV,GAAIW,CAAJ,EAAyB,0CAAA,CAA2CyB,IAA3C,CAAgDzB,CAAhD,CAAzB,CAA6E,MAAOgB,kBAAA,CAAkB3B,CAAlB,CAAqByB,MAArB,CAAxY,CAAjB,CAEhDE,QAASA,kBAAiB,CAACU,GAAD,CAAMC,GAAN,CAAW,CAAE,GAAW,IAAX,EAAIA,GAAJ,EAAmBA,GAAnB,CAAyBD,GAAzB,CAA6B9B,MAA7B,CAAqC+B,GAAA;AAAMD,GAAN,CAAU9B,MAAQ,KAAzD,IAAkEC,EAAI,CAAtE,CAAyE+B,KAAWC,KAAJ,CAAUF,GAAV,CAAvB,CAAuC9B,CAAvC,CAA2C8B,GAA3C,CAAgD9B,CAAA,EAAhD,CAAuD+B,IAAA,CAAK/B,CAAL,CAAA,CAAU6B,GAAA,CAAI7B,CAAJ,CAAU,OAAO+B,KAA3I,CAhCjCE,MAAAA,CAAyB7C,OAAA,CAAQ,0EAAR,CAEAA,QAAA8C,CAAQ,kFAARA,CAE7B,CAAuB5C,OAAvB,CAAgC,YAAhC,CAA8C,CAC5Ce,MAAO,CAAA,CADqC,CAA9C,CAIAf,QAAA,CAAQ,SAAR,CAAA,CAAqB,IAAK,EAE1B,KAAIuB,cAAgBoB,MAAA,CAAuB7C,OAAA,CAAQ,iEAAR,CAAvB,CAApB,CAEIS,SAAWoC,MAAA,CAAuB7C,OAAA,CAAQ,0EAAR,CAAvB,CAFf;AAIIQ,oBAAsBqC,MAAA,CAAuB7C,OAAA,CAAQ,wEAAR,CAAvB,CAJ1B,CAMIO,QAAUsC,MAAA,CAAuB7C,OAAA,CAAQ,kEAAR,CAAvB,CANd,CAQIuC,MAAQM,MAAA,CAAuB7C,OAAA,CAAQ,sEAAR,CAAvB,CARZ,CAUIgC,OAASa,MAAA,CAAuB7C,OAAA,CAAQ,0EAAR,CAAvB,CAVb,CAYI+C,UAAYF,MAAA,CAAuB7C,OAAA,CAAQ,6EAAR,CAAvB,CAZhB,CAcIgD;AAAUH,MAAA,CAAuB7C,OAAA,CAAQ,2EAAR,CAAvB,CAdd,CAgBIiD,SAAWJ,MAAA,CAAuB7C,OAAA,CAAQ,6EAAR,CAAvB,CA6QfE,QAAA,CAAQ,SAAR,CAAA,CAhQegD,QAAiB,CAACC,OAAD,CAAU,CAwBxCC,QAASA,UAAS,CAACd,IAAD,CAAO,CACvB,MAAOA,KAAA,CAAKe,OAAL,CAAa,SAAb,CAAwB,EAAxB,CAAA,CAA4BC,WAA5B,EADgB,CAKzBC,QAASA,SAAQ,CAACC,GAAD,CAAM,CACrB,IAAIC,IAAM,aAAA,CAAcC,IAAd,CAAmBF,GAAnB,CACV,OAAOC,IAAA,CAAME,GAAA,CAAIF,GAAA,CAAI,CAAJ,CAAJ,CAAN,CAAoBD,GAAA,CAAII,UAAJ,CAA0B,IAAX,GAAAJ,GAAA,CAAI,CAAJ,CAAA,CAAkB,CAAlB,CAAsB,CAArC,CAFN,CAMvBK,QAASA,UAAS,CAACC,KAAD,CAAQ,CACxB,IAAIC,OAAS,EAAb,CACIC,QAAU,EACd,EAAC,CAAA,CAAGf,QAAA,CAAS,SAAT,CAAJ,EAAyBE,OAAzB,CAAA,CAAkCf,IAAlC,CAAuCe,OAAvC;AAAgDW,KAAhD,CAAuD,0DAAvD,CAAmH,QAAS,CAACG,CAAD,CAAI,CAC9H,IAAIC,MAAQX,QAAA,CAASU,CAAA,CAAE,CAAF,CAAT,CAERC,MAAJ,CAAYF,OAAZ,CAAsB,CAAtB,GACED,MAEA,EAFUI,KAAA,CAAMA,MAAN,CAAaC,IAAA,CAAKC,GAAA,CAAIL,OAAJ,CAAc,CAAd,CAAL,CAAb,CAEV,CAAIE,KAAJ,CAAYF,OAAZ,CAAsB,CAAtB,GACED,MADF,EACYI,MAAA,CAAOA,MAAP,CAAcC,IAAA,CAAKC,GAAA,CAAIH,KAAJ,CAAY,CAAZ,CAAL,CAAd,CADZ,CAHF,CAQAF,QAAA,CAAUT,QAAA,CAASU,CAAA,CAAE,CAAF,CAAT,EAAiBA,CAAA,CAAE,CAAF,CAAjB,CAXoH,CAAhI,CAcc,MAAd,CAAID,OAAJ,GACED,MAEA,EAFUI,KAAA,CAAMA,MAAN,CAAaC,IAAA,CAAKC,GAAA,CAAIL,OAAJ,CAAc,CAAd,CAAL,CAAb,CAEV,CAAc,KAAd,CAAIA,OAAJ,GACED,MADF,EACY,UADZ,CAHF,CAQA,OAAOA,OAzBiB,CAjB1B,IAAIO,QAAU,EAAd,CAEIX,IAAMR,OAANQ,CAAcY,IAFlB,CAGIF,IAAMlB,OAANkB,CAAcG,IAHlB,CAIIJ,KAAOjB,OAAPiB,CAAeK,KAqFnBtB,QAAA,CAAQuB,QAAR,CACA,uCADA,CACyC,QAAS,CAACC,KAAD;AAAQC,KAAR,CAAeC,KAAf,CAAsB,CAOtE,IAAIC,UAAyB,GAAzBA,GAAYH,KAAA,CAAM,CAAN,CAAZG,EAAgC,CAAC,CAACH,KAAA,CAAM,CAAN,CAAtC,CAEII,aAAe,CAAC,CAAA,CAAGhC,SAAA,CAAU,SAAV,CAAJ,EAA0B8B,KAA1B,CAAA,CAAiCzC,IAAjC,CAAsCyC,KAAtC,CAA6C,GAA7C,CAEfG,MAAAA,CAAO5B,SAAA,CAAUuB,KAAA,CAAM,CAAN,CAAV,EAAsBA,KAAA,CAAM,CAAN,CAAtB,CAEX,KAAIM,KAAOX,OAAA,CAAQU,KAAR,CAEX,IAAiB,GAAjB,GAAIL,KAAA,CAAM,CAAN,CAAJ,EAAwBA,KAAA,CAAM,CAAN,CAAxB,CACE,KAAM,KAAIO,WAAJ,CAfaC,0BAeb,CAAiCR,KAAA,CAAM,CAAN,CAAjC,CAAN,CAGF,GAAI,CAACL,OAAA,CAAQc,cAAR,CAAuBJ,KAAvB,CAAL,CACE,KAAM,KAAIE,WAAJ,CAlBeG,wBAkBf,CAAmCV,KAAA,CAAM,CAAN,CAAnC,CAAN,CAIF,GAAIM,IAAJ,CAASK,SAAT,CAAoB,CAClBN,KAAA,CAAO5B,SAAA,CAAU6B,IAAV,CAAeK,SAAf,CAEP,IAAI,CAAChB,OAAA,CAAQc,cAAR,CAAuBJ,KAAvB,CAAL,CAAmC,CACjC,IAAIO,SAEJ,MAAM,KAAIC,cAAJ,CAAmB,CAAC,CAAA,CAAGxC,OAAA,CAAQ,SAAR,CAAJ,EAAwBuC,SAAxB;AAAoCpB,EAAA,CAAGA,MAAH,CA3B3CsB,6BA2B2C,CAA4Bd,KAAA,CAAM,CAAN,CAA5B,CAAsC,SAAtC,CAApC,CAAA,CAAmFvC,IAAnF,CAAwFmD,SAAxF,CAAmGN,IAAnG,CAAwGK,SAAxG,CAAnB,CAAN,CAHiC,CAMnCL,IAAA,CAAOX,OAAA,CAAQU,KAAR,CACPF,UAAA,CAAY,CAACA,SAVK,CAapB,GAAMY,CAAAT,IAAAS,CAAKA,GAAX,EAAkBX,CAAAA,YAAlB,CACE,KAAM,KAAIG,WAAJ,CAlCcS,yCAkCd,CAAkChB,KAAA,CAAM,CAAN,CAAlC,CAAN,CAGF,GAAII,YAAJ,CAAkB,CAChB,GAAc,OAAd,GAAIH,KAAJ,CACE,KAAM,KAAIM,WAAJ,CAtCgBU,sEAsChB,CAAN,CAvDAC,KAAAA,CA0DuBf,SA1DhB,CAAY,IAAZ,CAAmB,OACvB,IAAA,EAAA,KAAA,CAAA,OAAA,CAAA,KAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAwB,KAAA,CAAA,OAAA,CAAA,KAAA,CAAA,KAAA,wBA1B3BG,MAAAA,CAAOX,OAAA,CA0BoBU,KA1BpB,CACPc;SAAAA,CAAW,EAEXb,MAAJ,CAASS,GAAT,EAAgB,CAACT,KAAD,CAAMc,SAAtB,GAGED,SAHF,CAGa,CAAC,CAAA,CAAG9C,OAAA,CAAQ,SAAR,CAAJ,EAAwBgD,wBAAxB,CAAmC7B,GAAA,CAAIA,MAAJ,CAAWc,KAAX,CAAgBS,GAAhB,CAAqB,GAArB,CAAnC,CAAA,CAA8DtD,IAA9D,CAAmE4D,wBAAnE,CAA6Ef,KAAA,CAAKgB,MAAL,CAAc,GAAd,CAAoB,EAAjG,CAHb,CAMIhB,MAAJ,CAASgB,MAAT,GACEH,SADF,EACcb,KADd,CACmBgB,MADnB,CAIA,IAAIhB,KAAJ,CAASc,SAAT,EAAsBd,KAAtB,CAA2BS,GAA3B,CAAgC,CAC9B,IAAIQ,SAEJJ,UAAA,EAAY,CAAC,CAAA,CAAG9C,OAAA,CAAQ,SAAR,CAAJ,EAAwBkD,SAAxB,CAAoC/B,EAAA,CAAGA,MAAH,CAAUc,KAAA,CAAKgB,MAAL,CAAc,GAAd,CAAoB,EAA9B,CAAkC,GAAlC,CAApC,CAAA,CAA4E7D,IAA5E,CAAiF8D,SAAjF,CAA4FjB,KAA5F,CAAiGS,GAAjG,CAAsG,GAAtG,CAHkB,CAOhC,wBAAA,CAAOZ,SAAA,CAAYX,QAAA,CAASA,MAAT,CAAgB2B,SAAhB,CAA0B,+CAA1B,CAAZ,CAA4F3B,KAAA,CAAMA,MAAN,CAAa2B,SAAb;AAAuB,GAAvB,CAMpE,MAAA,CAAA,KAAA,CAAA,KAAA,CAAA,CAAA,wBAAxB,CAyDL,MAzDK,MAoDW,CAQlB,MAAiB,OAAV,GAAAlB,KAAA,CAAoB,SAAA,CA3FpBN,OAAA,CA2FoBU,KA3FpB,CAAA,CADIa,IACJ,CA2FoB,GA3FIvB,OAAA,CA2FJU,KA3FI,CAAA,CADpBa,IACoB,CA2FJ,CA3F0BhC,SAAA,CAAUS,OAAA,CA2FpCU,KA3FoC,CAAV,CAAwBU,GAAxB,CA2F1B,EAAA,IAAA,CAAA,GAApB,CAAoE,EAAA,CAAA,MAAA,EAAA,SAAA,CAAA,IAAA,CAAA,GAAA,EAAA,IAAA,CAAA,GAAA,CAAA,GAAA,CAjDL,CADxE,CAmDG,CACDd,MAAO,KADN,CAEDuB,cAAe,GAFd,CAGDC,SAAU,IAHT,CAnDH,CAqFAjD,QAAA,CAAQkD,cAAR,CAAyBC,QAAS,CAACC,IAAD,CAAO,CAInCC,IAAAA,CAAYrG,0BAAA,CAA2BoG,IAA3B,CAAhB,KACIE,KAEJ,IAAI,CACF,IAAKD,IAAA,CAAU1F,CAAV,EAAL,CAAoB,EAAE2F,KAAF,CAAUD,IAAA,CAAUzF,CAAV,EAAV,EAAyBC,IAA7C,CAAA,CAAoD,CAClD,IAAIiE,KAAOwB,KAAPxB,CAAahE,KAEjB,IAAI,CAACgE,IAAD,CAAM3C,IAAV,CACE,KAAUoE,MAAJ,CAXMC,6BAWN,CAAN,CAGF,GAAI,EAAE1B,IAAF,CAAOK,SAAP,EAAoBL,IAApB,CAAyBS,GAAzB;AAAgCT,IAAhC,CAAqCgB,MAArC,CAAJ,CACE,KAAUS,MAAJ,CAdME,sCAcN,CAAwB3B,IAAxB,CAA6B3C,IAA7B,CAAN,CAGFgC,OAAA,CAAQlB,SAAA,CAAU6B,IAAV,CAAe3C,IAAf,CAAR,CAAA,CAAgC2C,IAE5BA,KAAJ,CAAS4B,KAAT,GACEvC,OAAA,CAAQlB,SAAA,CAAU6B,IAAV,CAAe4B,KAAf,CAAR,CADF,CACmC5B,IADnC,CAbkD,CADlD,CAoBF,MAAOzD,GAAP,CAAY,CACZgF,IAAA,CAAUtF,CAAV,CAAYM,GAAZ,CADY,CApBd,OAsBU,CACRgF,IAAA,CAAUpF,CAAV,EADQ,CAIV+B,OAAA,CAAQ2D,KAAR,CAAcC,KAAd,CAAoB,UAApB,CAjCuC,CA0DzC5D,QAAA,CAAQ6D,mBAAR,CAA8BC,QAAS,CAAC3E,IAAD,CAAO,CACxC0C,IAAAA,CAAO5B,SAAA,CAAUd,IAAV,CACX,OAAOgC,QAAA,CAAQU,IAAR,CAFqC,CA1PN,CAiQ1C/E,OAAA,CAAOC,OAAP,CAAiBA,OAAjB,CAAyBgH,OA3SuF;\",\n\"sources\":[\"node_modules/xregexp/lib/addons/unicode-base.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$xregexp$lib$addons$unicode_base\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime-corejs3/helpers/interopRequireDefault\\\");\\n\\nvar _Object$defineProperty = require(\\\"@babel/runtime-corejs3/core-js-stable/object/define-property\\\");\\n\\n_Object$defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _getIterator2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js/get-iterator\\\"));\\n\\nvar _isArray = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/array/is-array\\\"));\\n\\nvar _getIteratorMethod2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js/get-iterator-method\\\"));\\n\\nvar _symbol = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/symbol\\\"));\\n\\nvar _from = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/array/from\\\"));\\n\\nvar _slice = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/slice\\\"));\\n\\nvar _includes = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/includes\\\"));\\n\\nvar _concat = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/concat\\\"));\\n\\nvar _forEach = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/for-each\\\"));\\n\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _symbol[\\\"default\\\"] === \\\"undefined\\\" || (0, _getIteratorMethod2[\\\"default\\\"])(o) == null) { if ((0, _isArray[\\\"default\\\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\"number\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2[\\\"default\\\"])(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { var _context4; if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = (0, _slice[\\\"default\\\"])(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return (0, _from[\\\"default\\\"])(o); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\n/*!\\n * XRegExp Unicode Base 4.4.1\\n * <xregexp.com>\\n * Steven Levithan (c) 2008-present MIT License\\n */\\nvar _default = function _default(XRegExp) {\\n  /**\\n   * Adds base support for Unicode matching:\\n   * - Adds syntax `\\\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\\\P{..}` or\\n   *   `\\\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\\n   *   braces for token names that are a single letter (e.g. `\\\\pL` or `PL`).\\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\\n   *\\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\\n   *\\n   * @requires XRegExp\\n   */\\n  // ==--------------------------==\\n  // Private stuff\\n  // ==--------------------------==\\n  // Storage for Unicode data\\n  var unicode = {}; // Reuse utils\\n\\n  var dec = XRegExp._dec;\\n  var hex = XRegExp._hex;\\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\\n\\n  function normalize(name) {\\n    return name.replace(/[- _]+/g, '').toLowerCase();\\n  } // Gets the decimal code of a literal code unit, \\\\xHH, \\\\uHHHH, or a backslash-escaped literal\\n\\n\\n  function charCode(chr) {\\n    var esc = /^\\\\\\\\[xu](.+)/.exec(chr);\\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\\\\\' ? 1 : 0);\\n  } // Inverts a list of ordered BMP characters and ranges\\n\\n\\n  function invertBmp(range) {\\n    var output = '';\\n    var lastEnd = -1;\\n    (0, _forEach[\\\"default\\\"])(XRegExp).call(XRegExp, range, /(\\\\\\\\x..|\\\\\\\\u....|\\\\\\\\?[\\\\s\\\\S])(?:-(\\\\\\\\x..|\\\\\\\\u....|\\\\\\\\?[\\\\s\\\\S]))?/, function (m) {\\n      var start = charCode(m[1]);\\n\\n      if (start > lastEnd + 1) {\\n        output += \\\"\\\\\\\\u\\\".concat(pad4(hex(lastEnd + 1)));\\n\\n        if (start > lastEnd + 2) {\\n          output += \\\"-\\\\\\\\u\\\".concat(pad4(hex(start - 1)));\\n        }\\n      }\\n\\n      lastEnd = charCode(m[2] || m[1]);\\n    });\\n\\n    if (lastEnd < 0xFFFF) {\\n      output += \\\"\\\\\\\\u\\\".concat(pad4(hex(lastEnd + 1)));\\n\\n      if (lastEnd < 0xFFFE) {\\n        output += '-\\\\\\\\uFFFF';\\n      }\\n    }\\n\\n    return output;\\n  } // Generates an inverted BMP range on first use\\n\\n\\n  function cacheInvertedBmp(slug) {\\n    var prop = 'b!';\\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\\n  } // Combines and optionally negates BMP and astral data\\n\\n\\n  function buildAstral(slug, isNegated) {\\n    var item = unicode[slug];\\n    var combined = '';\\n\\n    if (item.bmp && !item.isBmpLast) {\\n      var _context;\\n\\n      combined = (0, _concat[\\\"default\\\"])(_context = \\\"[\\\".concat(item.bmp, \\\"]\\\")).call(_context, item.astral ? '|' : '');\\n    }\\n\\n    if (item.astral) {\\n      combined += item.astral;\\n    }\\n\\n    if (item.isBmpLast && item.bmp) {\\n      var _context2;\\n\\n      combined += (0, _concat[\\\"default\\\"])(_context2 = \\\"\\\".concat(item.astral ? '|' : '', \\\"[\\\")).call(_context2, item.bmp, \\\"]\\\");\\n    } // Astral Unicode tokens always match a code point, never a code unit\\n\\n\\n    return isNegated ? \\\"(?:(?!\\\".concat(combined, \\\")(?:[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\0-\\\\uFFFF]))\\\") : \\\"(?:\\\".concat(combined, \\\")\\\");\\n  } // Builds a complete astral pattern on first use\\n\\n\\n  function cacheAstral(slug, isNegated) {\\n    var prop = isNegated ? 'a!' : 'a=';\\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\\n  } // ==--------------------------==\\n  // Core functionality\\n  // ==--------------------------==\\n\\n  /*\\n   * Add astral mode (flag A) and Unicode token syntax: `\\\\p{..}`, `\\\\P{..}`, `\\\\p{^..}`, `\\\\pC`.\\n   */\\n\\n\\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\\\p{^}`\\n  /\\\\\\\\([pP])(?:{(\\\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\\\P{..} or \\\\p{^..}\\n\\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\\n\\n    var isAstralMode = (0, _includes[\\\"default\\\"])(flags).call(flags, 'A'); // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\\\p{}`\\n\\n    var slug = normalize(match[4] || match[3]); // Token data object\\n\\n    var item = unicode[slug];\\n\\n    if (match[1] === 'P' && match[2]) {\\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\\n    }\\n\\n    if (!unicode.hasOwnProperty(slug)) {\\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\\n    } // Switch to the negated form of the referenced Unicode token\\n\\n\\n    if (item.inverseOf) {\\n      slug = normalize(item.inverseOf);\\n\\n      if (!unicode.hasOwnProperty(slug)) {\\n        var _context3;\\n\\n        throw new ReferenceError((0, _concat[\\\"default\\\"])(_context3 = \\\"\\\".concat(ERR_UNKNOWN_REF + match[0], \\\" -> \\\")).call(_context3, item.inverseOf));\\n      }\\n\\n      item = unicode[slug];\\n      isNegated = !isNegated;\\n    }\\n\\n    if (!(item.bmp || isAstralMode)) {\\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\\n    }\\n\\n    if (isAstralMode) {\\n      if (scope === 'class') {\\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\\n      }\\n\\n      return cacheAstral(slug, isNegated);\\n    }\\n\\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \\\"\\\".concat((isNegated ? '[^' : '[') + item.bmp, \\\"]\\\");\\n  }, {\\n    scope: 'all',\\n    optionalFlags: 'A',\\n    leadChar: '\\\\\\\\'\\n  });\\n  /**\\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\\\p` or `\\\\P`.\\n   *\\n   * @memberOf XRegExp\\n   * @param {Array} data Objects with named character ranges. Each object may have properties\\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\\n   *   `astral` data should be a combination of literal characters and `\\\\xHH` or `\\\\uHHHH` escape\\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\\n   *   defined as the exact inverse of another token.\\n   * @example\\n   *\\n   * // Basic use\\n   * XRegExp.addUnicodeData([{\\n   *   name: 'XDigit',\\n   *   alias: 'Hexadecimal',\\n   *   bmp: '0-9A-Fa-f'\\n   * }]);\\n   * XRegExp('\\\\\\\\p{XDigit}:\\\\\\\\p{Hexadecimal}+').test('0:3D'); // -> true\\n   */\\n\\n  XRegExp.addUnicodeData = function (data) {\\n    var ERR_NO_NAME = 'Unicode token requires name';\\n    var ERR_NO_DATA = 'Unicode token has no character data ';\\n\\n    var _iterator = _createForOfIteratorHelper(data),\\n        _step;\\n\\n    try {\\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n        var item = _step.value;\\n\\n        if (!item.name) {\\n          throw new Error(ERR_NO_NAME);\\n        }\\n\\n        if (!(item.inverseOf || item.bmp || item.astral)) {\\n          throw new Error(ERR_NO_DATA + item.name);\\n        }\\n\\n        unicode[normalize(item.name)] = item;\\n\\n        if (item.alias) {\\n          unicode[normalize(item.alias)] = item;\\n        }\\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\\n      // flags might now produce different results\\n\\n    } catch (err) {\\n      _iterator.e(err);\\n    } finally {\\n      _iterator.f();\\n    }\\n\\n    XRegExp.cache.flush('patterns');\\n  };\\n  /**\\n   * @ignore\\n   *\\n   * Return a reference to the internal Unicode definition structure for the given Unicode\\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\\\p` or `\\\\P` regex\\n   * constructs.\\n   *\\n   * @memberOf XRegExp\\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\\n   *   Properties and Property Aliases.\\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\\n   *\\n   * @note\\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\\n   *\\n   * @note\\n   * This method is *not* part of the officially documented API and may change or be removed in\\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\\n   * structures set up by XRegExp.\\n   */\\n\\n\\n  XRegExp._getUnicodeProperty = function (name) {\\n    var slug = normalize(name);\\n    return unicode[slug];\\n  };\\n};\\n\\nexports[\\\"default\\\"] = _default;\\nmodule.exports = exports.default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_createForOfIteratorHelper\",\"o\",\"allowArrayLike\",\"it\",\"_symbol\",\"_getIteratorMethod2\",\"_isArray\",\"_unsupportedIterableToArray\",\"length\",\"i\",\"F\",\"s\",\"n\",\"done\",\"value\",\"e\",\"_e\",\"f\",\"TypeError\",\"normalCompletion\",\"didErr\",\"err\",\"_getIterator2\",\"step\",\"next\",\"_e2\",\"minLen\",\"_context4\",\"_arrayLikeToArray\",\"_slice\",\"Object\",\"prototype\",\"toString\",\"call\",\"constructor\",\"name\",\"_from\",\"test\",\"arr\",\"len\",\"arr2\",\"Array\",\"_interopRequireDefault\",\"_Object$defineProperty\",\"_includes\",\"_concat\",\"_forEach\",\"_default\",\"XRegExp\",\"normalize\",\"replace\",\"toLowerCase\",\"charCode\",\"chr\",\"esc\",\"exec\",\"dec\",\"charCodeAt\",\"invertBmp\",\"range\",\"output\",\"lastEnd\",\"m\",\"start\",\"concat\",\"pad4\",\"hex\",\"unicode\",\"_dec\",\"_hex\",\"_pad4\",\"addToken\",\"match\",\"scope\",\"flags\",\"isNegated\",\"isAstralMode\",\"slug\",\"item\",\"SyntaxError\",\"ERR_DOUBLE_NEG\",\"hasOwnProperty\",\"ERR_UNKNOWN_NAME\",\"inverseOf\",\"_context3\",\"ReferenceError\",\"ERR_UNKNOWN_REF\",\"bmp\",\"ERR_ASTRAL_ONLY\",\"ERR_ASTRAL_IN_CLASS\",\"prop\",\"combined\",\"isBmpLast\",\"_context\",\"astral\",\"_context2\",\"optionalFlags\",\"leadChar\",\"addUnicodeData\",\"XRegExp.addUnicodeData\",\"data\",\"_iterator\",\"_step\",\"Error\",\"ERR_NO_NAME\",\"ERR_NO_DATA\",\"alias\",\"cache\",\"flush\",\"_getUnicodeProperty\",\"XRegExp._getUnicodeProperty\",\"default\"]\n}\n"]